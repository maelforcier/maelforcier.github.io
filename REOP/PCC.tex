\documentclass{beamer}

%\documentclass{article}
%\usepackage[envcountsect]{beamerarticle}

% Do NOT take this file as a template for your own talks. Use a file
% in the directory solutions instead. They are much better suited.

% Try the class options [notes], [notes=only], [trans], [handout],
% [red], [compress], [draft] and see what happens!

% Copyright 2003 by Till Tantau <tantau@users.sourceforge.net>.
%
% This program can be redistributed and/or modified under the terms
% of the LaTeX Project Public License Distributed from CTAN
% archives in directory macros/latex/base/lppl.txt.

% For a green structure color use:
%\colorlet{structure}{green!50!black}



\mode<article> % only for the article version
{
  \usepackage{fullpage}
  \usepackage{hyperref}
}


\mode<presentation> {
  %\setbeamertemplate{background canvas}[vertical shading][bottom=red!10,top=blue!10]

  %\usetheme{Singapore}
\usetheme{Madrid}

%\usecolortheme{dove}
  \usefonttheme[onlysmall]{structurebold}
}
%\setbeamercolor{math text}{fg=green!50!black}
%\setbeamercolor{normal text in math text}{parent=math text}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}

%\usepackage[frenchb]{babel}

\usepackage{graphicx}
\usepackage{times}

\setbeamercovered{dynamic}
\setbeamertemplate{navigation symbols}{}

\newcounter{algo}

\newenvironment{algo}{\medskip\begin{list}{}{%
\setlength{\leftmargin}{4cm}%
\setlength{\listparindent}{0pt}%
\setlength{\itemindent}{0pt}%
\usecounter{algo}}\item }{\end{list}\medskip}

\newtheorem{conjecture}{Conjecture}
\newtheorem{thm}{Théorème}
\newtheorem{proposition}{Proposition}


\def\ind{\mathbf{1}}
\def\alp{\alpha}
\def\lam{\lambda}
\def\cal{\mathcal}
\def\C{{\mathbb C}}
\def\N{{\mathbb N}}
\def\R{{\mathbb R}}
\def\Z{{\mathbb Z}}
\def\P{{\mathbb P}}
\def\E{{\mathbb E}}
\def\Var{\mathrm{Var}}
\def\Cov{\mathrm{Cov}}
\def\eps{\varepsilon}
\def\Wdir{./}
\def\etal{{\em et al.}}
\def\un{\mathbbm{1}}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\green{\color{green}}
\def\red{\color{red}}
\def\blue{\color{blue}}
\def\black{\color{black}}
\def\magenta{\color{magenta}}
\def\cyan{\color{cyan}}

\def\ds{\displaystyle}




\newenvironment{changemargin}[2]{\begin{list}{}{%
\setlength{\topsep}{0pt}%
\setlength{\leftmargin}{0pt}%
\setlength{\rightmargin}{0pt}%
\setlength{\listparindent}{\parindent}%
\setlength{\itemindent}{\parindent}%
\setlength{\parsep}{0pt plus 1pt}%
\addtolength{\leftmargin}{#1}%
\addtolength{\rightmargin}{#2}%
}\item }{\end{list}}



\title[]{Plus courts chemins\\ et programmation dynamique discrète}
\author[Université Paris Est, Ecole des Ponts]{Maël Forcier}

\date{7 octobre 2020}
\pgfdeclaremask{tu}{beamer-tu-logo-mask}
\pgfdeclaremask{ur}{beamer-ur-logo-mask}
\pgfdeclareimage[mask=tu,width=0.6cm]{tu-logo}{beamer-tu-logo}
\pgfdeclareimage[mask=ur,width=1cm]{ur-logo}{beamer-ur-logo}

\begin{document}
\boldmath
\begin{frame}

\titlepage

École des Ponts, France\\
\end{frame}

\begin{frame}\frametitle{Un exemple}
\centering
\only<1>{
\includegraphics[width=8cm]{djund.pdf}
}

\only<2>{
\includegraphics[width=8cm]{djund_solu.pdf}
}

Trouver le trajet le plus court dans ce réseau, i.e. {\red la $s$-$t$ chaîne de plus petit poids} dans ce graphe.



\only<2>{
Solution : poids minimal = 15
}
\end{frame}



\begin{frame}\frametitle{Cas général : Difficile !}

Problème du plus court chemin :

\begin{thm} 
Trouver le poids minimal d'un $s$-$t$ chemin élémentaire lorsque le graphe a des poids quelconques est {\bf NP}-difficile.
\end{thm}

\bigskip

Contient le problème du chemin hamiltonien.
\end{frame}



\begin{frame}\frametitle{Plan}
\begin{enumerate}
%\item Graphes orientés : quelques définitions.
\item Plus courts chemins dans les graphes orientés.
\begin{itemize}
\item[$\red\bullet$] Tous les poids sont $\geq 0$: Dijkstra.
\item[$\red\bullet$] Le graphe est sans circuit 

%\includegraphics[width=4cm]{nocircuit.pdf}

\item[$\red\bullet$] Et sinon ?
\end{itemize}
\item Plus courte chaîne dans les graphes non-orientés.
\begin{itemize}
\item[$\red\bullet$] Tous les poids sont $\geq 0$ : Encore Dijkstra.
\item[$\red\bullet$] Et sinon ?
\end{itemize}
\end{enumerate}
\end{frame}


% \begin{frame}\frametitle{}
% \begin{center}{\huge Graphes orientés : quelques définitions }\end{center}
% \end{frame}

% \begin{frame}\frametitle{Graphes orientés}
% {\footnotesize
% graphe orienté$=$ brique de base en modélisation.

% \bigskip

% graphe : $D=(V,A)$

% \bigskip

% $V$ : ensemble de {\blue sommets}
% $A$ : ensemble d'{\blue arcs} ; à tout arc correspond un couple de sommets

% \bigskip

%  arc $(u,v)$ : $u$ est le {\blue prédécesseur} de $v$ et $v$ est le {\blue successeur} de $u$.}
% \begin{center}
% \includegraphics[height=4cm]{dgraph.pdf}
% \end{center}
% \end{frame}

% \begin{frame}\frametitle{Graphes orientés: Chemins}

% {\blue chemin} $=$ suite de la forme
% $$v_0,a_1,v_1,\ldots,a_k,v_k$$ 
% $v_i\in V$, $a_j\in A$ avec $a_j=(v_{j-1},v_j)$

% \bigskip

% Chemin ne passant
% jamais plus d'une fois sur un arc = chemin {\blue
% simple}. 

% \bigskip

% Chemin ne passant
% jamais plus d'une fois sur un sommet = chemin {\blue
% élémentaire}. 

% \bigskip

% Chemin simple passant par tous les arcs = chemin {\blue eulérien} 

% \bigskip

% Chemin élémentaire passant par
% tous les sommets = chemin {\blue hamiltonien}.
% \end{frame}

% \begin{frame}\frametitle{Graphes orientés : Chemin eulérien}
% \begin{figure}
% \begin{center}
% \includegraphics[height=5cm]{deuler.pdf}
% \end{center}
% \end{figure}
% \end{frame}

% \begin{frame}\frametitle{Graphes orientés: circuits}

% {\blue chemin} $=$ suite de la forme
% $$v_0,a_1,v_1,\ldots,a_k,v_k$$ 
% $v_i\in V$, $a_j\in A$ avec $a_j=(v_{j-1},v_j)$ 

% \bigskip
% \bigskip

% Chemin simple fermé ($v_0=v_k$) = {\blue circuit}

% \bigskip
% \bigskip

% {\blue Circuit élémentaire, circuit hamiltonien, circuit eulérien}

% \end{frame}

\begin{frame}\frametitle{Graphe non-orienté / orienté}
\begin{center}
\begin{tabular}{c|c}
graphe non-orienté & graphe orienté \\
\hline
$G=(V,E)$ & $D=(V,A)$ \\
arête & arc \\
chaîne & chemin \\
cycle & circuit \\

\includegraphics[width=5.5cm]{djund.pdf}
&\includegraphics[width=5.5cm]{dj.pdf}
\end{tabular}
\end{center}
\end{frame}


\begin{frame}\frametitle{}
\begin{center}{\huge Plus courts chemins dans les graphes orientés}\end{center}
\end{frame}

\begin{frame}\frametitle{Tous les coûts sont $\geq 0$}

Cas {\magenta le plus naturel} : tous les poids sont $\geq 0$.

\bigskip
\visible<2>{
Exemple : Modélisation d'un réseau de transport.}
\centering
\includegraphics[height=5cm]{dj.pdf}

\end{frame}


\begin{frame}\frametitle{L'algorithme de Dijkstra}
{\footnotesize
\begin{itemize}
\item Initialisation : $U:=V$, $\lambda(s):=0$ et $\lambda(v)=+\infty$ pour tout $v\neq s$.
\bigskip

\item Répéter 
\begin{enumerate}
\item Choisir $u$ minimisant $\lambda(u)$ dans $U$. 

\item Pour chaque $a=(u,v)\in A$ tq $\lambda(v)>\lambda(u)+c(a)$, redéfinir $\lambda(v):=\lambda(u)+c(a)$. 

\item Redéfinir $U:=U\setminus\{u\}$.
\end{enumerate}
\bigskip
\item Arrêt qd $\lambda(u)=+\infty$ pour tout $u\in U$ (en particulier arrêt si $U=\varnothing$).
\end{itemize}}
\end{frame}

\begin{frame}\frametitle{Exemple d'application}
\centering
${\small \begin{array}{cccccccc}s & a & b & c & d & e & f & t
\\ 
\hline (0) & (\infty) & (\infty) & (\infty) & (\infty) & (\infty) & (\infty) & (\infty) \\ 
\visible<2-9>{0 & (3) & (\infty) & (\infty) & (3) & (\infty) &  (5) & (\infty) \\}
\visible<3-9>{0 & 3 & (5) & (\infty) & (3) & (\infty) & (5) & (\infty) \\}
\visible<4-9>{0 & 3  & (4) & (\infty) & 3 & (\infty) & (5) & (\infty) \\}
\visible<5-9>{
0 & 3 & 4 & (5) & 3 & (\infty) & (5) & (\infty) \\}
\visible<6-9>{0 & 3 & 4 & 5 & 3 & (8) & (5) & (\infty) \\}
\visible<7-9>{
0 & 3 & 4 & 5 & 3 & (7) & 5 & (12) \\}
\visible<8-9>{
0 & 3 & 4 & 5 & 3 & 7 & 5 & (9) \\}
\visible<9>{0 & 3 & 4 & 5 & 3 & 7 & 5 & 9}
\end{array}}$
\end{frame}


\begin{frame}\frametitle{L'algorithme de Dijkstra}


 Algorithme peut être facilement adapté pour calculer le chemin lui-même (et pas seulement le poids minimum)
 
 \bigskip
  \bigskip

\begin{thm}
Etant donné un graphe orienté $D=(V,A)$, deux sommets $s,t$ et une fonction de poids $w:A\rightarrow\mathbb{R}_+$, un $s$-$t$ chemin de plus petit poids peut être trouvé en $O(n^2)$.
\end{thm} 


 

\end{frame}

\begin{frame}\frametitle{Un graphe sans circuit}
\includegraphics[width=10cm]{exacirc.pdf}
\end{frame}



\begin{frame}\frametitle{Equation de Bellman}

Posons pour tout sommet $v$
$$\lambda(v):=\mbox{ poids minimum d'un $s$-$v$ chemin}$$

{\scriptsize ($\lambda(v):=\infty$ si un tel chemin n'existe pas)}

\bigskip



Alors (équation de Bellman)
$$
\lambda(v)=\min_{(u,v)\in A}(\lambda(u)+w(u,v))
$$

\bigskip
\bigskip

{\scriptsize\em
``Le plus court chemin de $s$ à $v$ est le plus court chemin de $s$ à un antécédent $u$ de $v$ auquel on a ajouté le dernier arc $(u,v)$.''}
\end{frame}

\begin{frame}\frametitle{Suite de l'exemple}
\includegraphics[width=10cm]{exacirc_bad.pdf}
\end{frame}

\begin{frame}\frametitle{Suite de l'exemple}
\includegraphics[width=10cm]{exacirc_good.pdf}
\end{frame}



\begin{frame}\frametitle{L'algorithme}

{\footnotesize
Equation de Bellman ${\bf\red \rightarrow}$ algorithme. 
\bigskip
\bigskip

\begin{itemize}
\item Initialisation $\lambda(s):=0$ et $\lambda(u):=\infty$ pour tout $u$ tel qu'il n'existe pas de $s$-$u$ chemin. 

\bigskip

\item Répéter
\begin{enumerate}
\item Chercher $v$ dont on connaît $\lambda(u)$ pour tous les prédécesseurs $u$.

\item $\lambda(v):=\min_{(u,v)\in A}(\lambda(u)+w(u,v))$ {\scriptsize (équation de Bellman)}
\end{enumerate}

\bigskip

\item Arrêt quand $\lambda$ calculé pour tous les sommets.

\end{itemize}

\bigskip
\bigskip

 Graphe acircuitique ${\bf\red \rightarrow}$ il y a toujours un sommet $v$ dont on connaît tous les prédécesseurs.}
\end{frame}

\begin{frame}\frametitle{L'idée de Bellman}

Principe d'optimalité de Bellman

\bigskip

\begin{quote}
La sous-trajectoire d'une trajectoire optimale est encore optimale.
\end{quote}
\end{frame}

\begin{frame}\frametitle{Algorithme}
 Algorithme peut être facilement adapté pour calculer le chemin lui-même (et pas seulement le poids minimum)
 
\bigskip\bigskip 
 
\begin{thm}
Etant donné un graphe acircuitique $D=(V,A)$, deux sommets $s,t$ et une fonction de poids $w:A\rightarrow\mathbb{R}$, un $s$-$t$ chemin de plus petit poids peut être trouvé en $O(m)$. 
\end{thm}

\bigskip

Poids peuvent être positifs et négatifs ($\neq$ Dijkstra).

\bigskip

On peut donc également trouver {\red le plus long chemin élémentaire}.
\end{frame}




\begin{frame}\frametitle{Poids quelconques, pas forcément acircuitique}

Poids quelconques, et il peut y avoir des circuits : algorithme polynomial si le graphe est {\blue sans circuit absorbant}.

\bigskip

Circuit absorbant = circuit dont la somme des poids $< 0$.

\bigskip

Equation de Bellman.
\end{frame}


\begin{frame}\frametitle{Pas de circuit absorbant : équation de Bellman}
$\lambda(k,v):=\mbox{ poids minimum d'un $s$-$v$ chemin traversant exactement $k$ arcs.}$ 

\bigskip
\bigskip

Equation de Bellman :
$$
\lambda(k+1,v)=\min_{(u,v)\in A}(\lambda(k,u)+w(u,v))
$$
pour tout $v\in V$. 
\end{frame}

\begin{frame}\frametitle{L'algorithme}

{\footnotesize
Equation de Bellman ${\bf\red \rightarrow}$ algorithme. 
\bigskip
\bigskip

\begin{itemize}
\item Initialisation $\lambda(0,s):=0$, $\lambda(0,v):=+\infty$ pour $v\neq s$ et $k:=0$.

\bigskip

\item Répéter tant que $k\leq |V|-1$
\begin{enumerate}

\item Pour tout $v$, faire $\lambda(k+1,v):=\min_{(u,v)\in A}(\lambda(k,u)+w(u,v))$ {\scriptsize (équation de Bellman)}

\item $k:=k+1$
\end{enumerate}

\bigskip

\item Renvoyer $\min_{k=1,\ldots,|V|-1}\lambda(k,t)$.

\end{itemize} }


\end{frame}

\begin{frame}\frametitle{Pas de circuit absorbant}

 Algorithme peut être facilement adapté pour calculer le chemin lui-même (et pas seulement le poids minimum)
 
\bigskip\bigskip 
 
\begin{thm}
Etant donné un graphe $D=(V,A)$, deux sommets $s,t$ et une fonction de poids $w:A\rightarrow\mathbb{R}$ telle qu'il n'y ait pas circuit absorbant, un $s$-$t$ chemin de plus petit poids peut être trouvé en $O(nm)$. 
\end{thm}  
\end{frame}


\begin{frame}\frametitle{}
\begin{center}{\huge Plus courte chaîne dans les graphes non-orientés}\end{center}
\end{frame}


\begin{frame}\frametitle{Tous les poids sont $\geq 0$}

\begin{itemize}

\item Si tous les poids sont $\geq 0$, on applique encore Dijkstra.

\bigskip

\item Transformation : \includegraphics[width=7cm]{djun_dj.pdf}

\bigskip

\item Les plus courtes chaînes élémentaires correspondent aux plus courts chemins élémentaires.

\bigskip

\item Donne exactement le même algorithme.
\end{itemize}

\end{frame}

\begin{frame}\frametitle{S'il y a des poids $\leq 0$}

S'il y a des poids $\leq 0$, mais pas de cycle absorbant : on peut encore y arriver en temps polynomial.


\bigskip
\bigskip

Outils seront vus lors de la séance ``Tournée''.



\bigskip
\bigskip
{\footnotesize
{\red ATTENTION} : transfomation

\includegraphics[width=7cm]{djun_dj.pdf} 

ne permet pas de se ramener au cas orienté
(toute arête de poids négatif fait apparaître un circuit absorbant)}

\end{frame}


\begin{frame}\frametitle{Cas général}

\begin{thm} 
Trouver la $s$-$t$ chaîne élémentaire de poids minimum lorsque le graphe a des poids quelconques est {\bf NP}-difficile.
\end{thm}

\end{frame}

\begin{frame}\frametitle{Résumé}
{\small \begin{tabular}{c|c}

& Complexité \\
\hline
Graphe orienté,& $O(n^2)$  \\
 poids positifs  & (Dijkstra)\\
\hline
Graphe orienté,   & $O(m)$  \\ 
poids quelconques, acircuitique & (Programmation
dynamique)\\

\hline
Graphe orienté,  & $O(nm)$  \\  
poids quelconques, & (Programmation
dynamique, \\

sans circuit absorbant &  algorithme de Ford-Bellman) \\
\hline
Graphe orienté,  & {\bf NP}-difficile \\
poids quelconques & \\
\hline\hline
Graphe non-orienté,  & $O(n^2)$  \\ poids positifs & (Dijkstra) \\
\hline
Graphe non-orienté,   & $O(n^3)$ \\ poids quelconques, & (voir Séance Tournées)\\
pas de cycle absorbant & \\
\hline Graphe non-orienté, & {\bf NP}-difficile \\
 poids quelconques  &
\end{tabular}}
\end{frame}


\begin{frame}\frametitle{Programmation dynamique}

{\footnotesize
 On a
\begin{enumerate}
\item système dynamique à temps discret $x_{k+1}=f_k(x_k,u_k),\quad k=1,2,\ldots,N$
\item fonction de coût additive dans le temps.
\end{enumerate}

\bigskip

$x_0$ : {\blue état initial}.

\bigskip

$x_k$ : {\blue état} au début de la {\blue période $k$}. 

\bigskip

$u_k$ : {\blue décision} pour la période $k$.

\bigskip

$c_k(x_k,x_{k+1})$ : coût de la {\blue transition} de $x_k$ à $x_{k+1}$ sur la période $k$.

\bigskip\bigskip

Trouver la {\blue trajectoire} $x_0,x_1,\ldots,x_N$ de coût total $\sum_{k=1}^Nc_k(x_k,x_{k+1})$ minimal : 

peut se résoudre par la {\blue programmation dynamique}.}


\end{frame}

\begin{frame}\frametitle{Programmation dynamique}
$\lambda(k,x):=$ coût minimal de la trajectoire amenant le système dans l'état $x$ en $k$ étapes.

\bigskip
\bigskip

Programmation dynamique : équation de Bellman pour tout $y$

$$\lambda(k,y)=\min_{x\in X_{k-1}}(\lambda(k-1,x)+c_{k-1}(x,y))$$

\bigskip
\bigskip

Algorithme : calculer de proche en proche

\end{frame}


\begin{frame}\frametitle{Gestion de stock}
Dynamique d'un stock : $x_{k+1}=x_k-d_k+u_k$, 

\bigskip

$d_k$ : demande pour la période $k$ (supposée connue) 

$x_k\in\mathbb{Z}$ : nombre d'unités disponibles en début de période $k$ 

$u_k$ : nombre d'unités commandées (et reçues immédiatement) en début de période $k$ 

$K$ : capacité maximale de stockage

$c(u_k)+g(x_{k+1})$ : coût de gestion de stock pour la période $k$ en
\begin{itemize}
\item $c(u_k)$ coût de réapprovisionnement
\item  $g(x_{k+1})$ coût de stockage ou coût de pénurie 
\end{itemize}

\bigskip

{\red Objectif.} Minimiser $\sum_{k=0}^{N-1}c(u_k)+g(x_{k+1}).$ 

\end{frame}

\begin{frame}\frametitle{Gestion de stock}
Modélisation par la programmation dynamique

\bigskip

{\red périodes} : périodes $k=1,\ldots, N$

\bigskip

{\red états} : valeurs possibles $x_k$ de niveau de stock, 

\bigskip

{\red transitions} : $x_k\rightarrow x_{k+1}$ tq $x_{k+1}$ satisfasse simultanément $x_{k+1}\in\mathbb{Z}$, $x_{k+1}+d_k\leq K$ et $x_{k+1}\geq x_k-d_k$ 

\bigskip


{\red coût de la transition} : $x_k\rightarrow x_{k+1}$ est $c(x_{k+1}-x_k+d_k)+g(x_{k+1})$

\bigskip
\bigskip

{\red Objectif.} Minimiser $\sum_{k=0}^{N-1}c(x_{k+1}-x_k+d_k)+g(x_{k+1})$  (critère additif = somme des coûts des transitions de la trajectoire).

\end{frame}


\begin{frame}\frametitle{Programmation dynamique $=$ plus court chemin}
Programmation dynamique = plus court chemin dans un graphe acircuitique

\bigskip
\bigskip

\begin{center}
\begin{tabular}{c|c}Prog. dyn. & Plus court $s$-$t$ chemin\\
\hline
états $\times$ périodes & sommets \\
transitions & arcs \\
coût de la transition & longueur l'arc \\
trajectoire & chemin \\
trajectoire optimale & plus court chemin
\end{tabular}
\end{center}

Si plusieurs états de départ ou plusieurs états à l'arrivée, on peut ajouter des sommets fictifs $s$ et $t$, et des transitions de coût $=0$.

\end{frame}

\begin{frame}\frametitle{Programmation dynamique $=$ plus court chemin}
\includegraphics[width=10cm]{illustrdyn.pdf}
\end{frame}

\begin{frame}\frametitle{Programmation dynamique $=$ plus court chemin}
\includegraphics[width=10cm]{illustrdyn_opt.pdf}
\end{frame}

\begin{frame}\frametitle{Programmation dynamique $=$ plus court chemin}
\includegraphics[width=10cm]{illustrdyn_opt_truc.pdf}
\end{frame}

\end{document}