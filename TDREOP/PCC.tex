\documentclass{beamer}

%\documentclass{article}
%\usepackage[envcountsect]{beamerarticle}

% Do NOT take this file as a template for your own talks. Use a file
% in the directory solutions instead. They are much better suited.

% Try the class options [notes], [notes=only], [trans], [handout],
% [red], [compress], [draft] and see what happens!

% Copyright 2003 by Till Tantau <tantau@users.sourceforge.net>.
%
% This program can be redistributed and/or modified under the terms
% of the LaTeX Project Public License Distributed from CTAN
% archives in directory macros/latex/base/lppl.txt.

% For a green structure color use:
%\colorlet{structure}{green!50!black}



\mode<article> % only for the article version
{
  \usepackage{fullpage}
  \usepackage{hyperref}
}


\mode<presentation> {
  %\setbeamertemplate{background canvas}[vertical shading][bottom=red!10,top=blue!10]

  %\usetheme{Singapore}
\usetheme{Madrid}

%\usecolortheme{dove}
  \usefonttheme[onlysmall]{structurebold}
}
%\setbeamercolor{math text}{fg=green!50!black}
%\setbeamercolor{normal text in math text}{parent=math text}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}

%\usepackage[frenchb]{babel}

\usepackage{graphicx}
\usepackage{times}

\setbeamercovered{dynamic}
\setbeamertemplate{navigation symbols}{}

\newcounter{algo}

\newenvironment{algo}{\medskip\begin{list}{}{%
\setlength{\leftmargin}{4cm}%
\setlength{\listparindent}{0pt}%
\setlength{\itemindent}{0pt}%
\usecounter{algo}}\item }{\end{list}\medskip}

\newtheorem{conjecture}{Conjecture}
\newtheorem{thm}{Théorème}
\newtheorem{proposition}{Proposition}


\def\ind{\mathbf{1}}
\def\alp{\alpha}
\def\lam{\lambda}
\def\cal{\mathcal}
\def\C{{\mathbb C}}
\def\N{{\mathbb N}}
\def\R{{\mathbb R}}
\def\Z{{\mathbb Z}}
\def\P{{\mathbb P}}
\def\E{{\mathbb E}}
\def\Var{\mathrm{Var}}
\def\Cov{\mathrm{Cov}}
\def\eps{\varepsilon}
\def\Wdir{./}
\def\etal{{\em et al.}}
\def\un{\mathbbm{1}}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\green{\color{green}}
\def\red{\color{red}}
\def\blue{\color{blue}}
\def\black{\color{black}}
\def\magenta{\color{magenta}}
\def\cyan{\color{cyan}}

\def\ds{\displaystyle}




\newenvironment{changemargin}[2]{\begin{list}{}{%
\setlength{\topsep}{0pt}%
\setlength{\leftmargin}{0pt}%
\setlength{\rightmargin}{0pt}%
\setlength{\listparindent}{\parindent}%
\setlength{\itemindent}{\parindent}%
\setlength{\parsep}{0pt plus 1pt}%
\addtolength{\leftmargin}{#1}%
\addtolength{\rightmargin}{#2}%
}\item }{\end{list}}



\title[]{Plus courts chemins\\ et programmation dynamique discrète}
\author[Université Paris Est, Ecole des Ponts]{Maël Forcier}

\date{7 octobre 2020}
\pgfdeclaremask{tu}{beamer-tu-logo-mask}
\pgfdeclaremask{ur}{beamer-ur-logo-mask}
\pgfdeclareimage[mask=tu,width=0.6cm]{tu-logo}{beamer-tu-logo}
\pgfdeclareimage[mask=ur,width=1cm]{ur-logo}{beamer-ur-logo}

\AtBeginSection[] % TOC before each section
{
 \begin{frame}
  \frametitle{Table of Contents}
  \tableofcontents[currentsection]
 \end{frame}
}

\AtBeginSubsection[] % TOC before each section
{
 \begin{frame}
  \frametitle{Table of Contents}
  \tableofcontents[currentsubsection]
 \end{frame}
}

\begin{document}
\boldmath
\begin{frame}

\titlepage

École des Ponts, France\\
\end{frame}

\begin{frame}\frametitle{Un exemple}
\centering
\only<1>{
\includegraphics[width=8cm]{djund.pdf}
}

\only<2>{
\includegraphics[width=8cm]{djund_solu.pdf}
}

Trouver le chemin le plus court dans ce réseau,\\
 i.e. {\red le $s$-$t$ chemin de coût minimal} dans ce graphe.



\visible<2>{
Solution en bleu et coût minimal = 15
}
\end{frame}



\begin{frame}\frametitle{Définition}

Problème du plus court chemin :\\
\medskip
Étant donné un graphe $G=(V,E)$ et une fonction de coût $c : E \to \mathbb{Q}$,\\
Trouver un $o$-$d$ chemin \only<2>{{\red simple}} \only<3>{{\blue élémentaire}} $P$ de coût minimal $\sum_{e \in P}c(e)$
\pause

\bigskip

Rappel : 
\begin{itemize}
\item
un chemin {\red simple} visite chaque arc/arête au plus une fois
\pause
\item 
un  chemin {\blue élémentaire} visite chaque sommets au plus une fois
\end{itemize}

\end{frame}



\begin{frame}\frametitle{Cas général : Difficile !}

\begin{thm} 
Trouver le poids minimal d'un $o$-$d$ chemin élémentaire lorsque le graphe $G=(V,E)$ a des poids quelconques est {\bf NP}-difficile.
\end{thm}

\bigskip
\pause
Preuve:
Réduire au problème du plus court chemin élementaire.\\
\pause
\medskip
Réduire au problème de chemin hamiltonien :\\
\pause
\medskip
Prendre $c(e)=-1$ pour tout $e \in E$
\\
\medskip
\pause
Il existe un chemin hamiltonien\\
ssi le coût minimal est égal à $-(\operatorname{card}(V)-1)$

\end{frame}


\begin{frame}\frametitle{Graphe non-orienté / orienté}
\begin{center}
\begin{tabular}{c|c}
graphe non-orienté & graphe orienté \\
\hline
% $G=(V,E)$ & $D=(V,A)$ \\
% arête & arc \\
% chaîne & chemin \\
% cycle & circuit \\
\\
\includegraphics[width=5.5cm]{djund.pdf}
&\includegraphics[width=5.5cm]{dj.pdf}
\end{tabular}
\end{center}
\end{frame}


\begin{frame}
\frametitle{Réduction d'orienté à non-orienté}Réduction : \\
\begin{center}
\includegraphics[width=10cm]{djun_dj.pdf}
\end{center}

\pause
\bigskip
Peut permettre de d'utiliser des algorithmes de graphes orientés au cas non orienté
\end{frame}

\begin{frame}{Plan}
 \tableofcontents
\end{frame}

% \begin{frame}\frametitle{}
% \begin{center}{\huge Graphes orientés : quelques définitions }\end{center}
% \end{frame}

% \begin{frame}\frametitle{Graphes orientés}
% {\footnotesize
% graphe orienté$=$ brique de base en modélisation.

% \bigskip

% graphe : $D=(V,A)$

% \bigskip

% $V$ : ensemble de {\blue sommets}
% $A$ : ensemble d'{\blue arcs} ; à tout arc correspond un couple de sommets

% \bigskip

%  arc $(u,v)$ : $u$ est le {\blue prédécesseur} de $v$ et $v$ est le {\blue successeur} de $u$.}
% \begin{center}
% \includegraphics[height=4cm]{dgraph.pdf}
% \end{center}
% \end{frame}

% \begin{frame}\frametitle{Graphes orientés: Chemins}

% {\blue chemin} $=$ suite de la forme
% $$v_0,a_1,v_1,\ldots,a_k,v_k$$ 
% $v_i\in V$, $a_j\in A$ avec $a_j=(v_{j-1},v_j)$

% \bigskip

% Chemin ne passant
% jamais plus d'une fois sur un arc = chemin {\blue
% simple}. 

% \bigskip

% Chemin ne passant
% jamais plus d'une fois sur un sommet = chemin {\blue
% élémentaire}. 

% \bigskip

% Chemin simple passant par tous les arcs = chemin {\blue eulérien} 

% \bigskip

% Chemin élémentaire passant par
% tous les sommets = chemin {\blue hamiltonien}.
% \end{frame}

% \begin{frame}\frametitle{Graphes orientés : Chemin eulérien}
% \begin{figure}
% \begin{center}
% \includegraphics[height=5cm]{deuler.pdf}
% \end{center}
% \end{figure}
% \end{frame}

% \begin{frame}\frametitle{Graphes orientés: circuits}

% {\blue chemin} $=$ suite de la forme
% $$v_0,a_1,v_1,\ldots,a_k,v_k$$ 
% $v_i\in V$, $a_j\in A$ avec $a_j=(v_{j-1},v_j)$ 

% \bigskip
% \bigskip

% Chemin simple fermé ($v_0=v_k$) = {\blue circuit}

% \bigskip
% \bigskip

% {\blue Circuit élémentaire, circuit hamiltonien, circuit eulérien}

% \end{frame}

\section{Coûts positifs: Dijkstra}

\begin{frame}\frametitle{Tous les coûts sont $\geq 0$}

Cas {\magenta le plus naturel} : tous les poids sont $\geq 0$.

\bigskip
\visible<2>{
Exemple : Modélisation d'un réseau de transport.}
\centering
\includegraphics[height=5cm]{dj.pdf}

\end{frame}



\begin{frame}\frametitle{L'algorithme de Dijkstra}
{\footnotesize
\begin{itemize}
\item Initialisation : $U:=\emptyset$, $d(o):=0$ et $d(v)=+\infty$ pour tout $v\neq o$.
\bigskip

\item Tant que $V\backslash U\neq \emptyset$
\begin{enumerate}
\item Choisir $v$ minimisant $d(v)$ dans $V\backslash U$. 
\item $U:=U\cup \{ v\}$.
\item Pour chaque $a=(u,v)\in A$\\
		\begin{itemize}
		\item $d(v):=\min[d(v),d(u)+c(a)]$. 
		\end{itemize}
\end{enumerate}
%\bigskip
%\item Arrêt qd $\lambda(u)=+\infty$ pour tout $u\in U$ (en particulier arrêt si $U=\varnothing$).
\end{itemize}}
\end{frame}

\begin{frame}\frametitle{Exemple : Dijkstra}
\centering

\includegraphics[height=4cm]{dj.pdf}
${\small \begin{array}{cccccccc}s & a & b & c & d & e & f & t
\\ 
\hline (0) & (\infty) & (\infty) & (\infty) & (\infty) & (\infty) & (\infty) & (\infty) \\ 
\visible<2-9>{0 & (3) & (\infty) & (\infty) & (3) & (\infty) &  (5) & (\infty) \\}
\visible<3-9>{0 & 3 & (5) & (\infty) & (3) & (\infty) & (5) & (\infty) \\}
\visible<4-9>{0 & 3  & (4) & (\infty) & 3 & (\infty) & (5) & (\infty) \\}
\visible<5-9>{
0 & 3 & 4 & (5) & 3 & (\infty) & (5) & (\infty) \\}
\visible<6-9>{0 & 3 & 4 & 5 & 3 & (8) & (5) & (\infty) \\}
\visible<7-9>{
0 & 3 & 4 & 5 & 3 & (7) & 5 & (12) \\}
\visible<8-9>{
0 & 3 & 4 & 5 & 3 & 7 & 5 & (9) \\}
\visible<9>{0 & 3 & 4 & 5 & 3 & 7 & 5 & 9}
\end{array}}$
\end{frame}


\begin{frame}\frametitle{L'algorithme de Dijkstra}


Peut être facilement adapté pour calculer le chemin lui-même (et pas seulement le coût minimum)
 
 \bigskip

 \pause
  \bigskip
Fonctionne sur les graphes non-orientés (cf réduction précédente)

 \pause
  \bigskip

Converge en $O(m+n log(n))$ avec\\
$n$: nombre de sommets\\
$m$: nombres d'arcs


\end{frame}

\section{Programmation Dynamique Ford-Bellman}

\subsection{L'algorithme de Ford-Bellman}

\begin{frame}\frametitle{L'idée de Bellman}

Principe d'optimalité de Bellman\\
\pause
La sous-trajectoire d'une trajectoire optimale est encore optimale:

 \begin{proposition}[5.2]
  Soit $P$ un $o$-$v$ chemin avec $k$ arcs et $Q$ son sous-$o$-$u$ chemin, pù $u$ iest le sommet avant $v$ dans $P$. Si $P$ est le plus petit $o -v$ chemin parmie ceux à $k$ arcs, alors $Q$ est le plus petit $o$-$u$ parmi ceux à $k-1$ arcs.
 \end{proposition}
 \vfill
 \pause
 Preuve:
  \begin{itemize}
   \item Par l'absurde soit $Q'$ $o$-$u$ chemin avec $k-1$ arcs tel que $c(Q') < c(Q)$. 
   \pause
   \item $P' = Q' \cup (u, v)$ est un $o$-$v$ chemin avec $k$ arcs.
   \pause
   \item $c(P') = c(Q') + c(u, v) < c(Q) + c(u, v) = c(P)$. \qedhere
  \end{itemize}

\end{frame}

\begin{frame}{Algorithme de Ford-Bellman}
 Le coût minimal $f(v,k)$ d'un $o$-$v$
  chemin  à $k$ arcs vérifie l'équation de Bellman
 \begin{align*}
  f(v, k+1) & = \min_{u \in N^-(v)} f(u, k-1) + c(u, v) \\
  f(v, 0) & = \begin{cases}
   0        & \text{if $v = o$} \\
   + \infty & \text{otherwise}  
  \end{cases}                 
 \end{align*}
  \pause
 On peut calculer récursivement à partir de $k=0$. 
 \pause
 Critère d'arrêt ?
 \vfill
 Solution: \\
Besoin d'ajouter une hypothèse : le graphe $G$ n'a pas de cycles négatifs.

\vfill
\pause
S'il $G$ n'a pas de cycles négatifs, il y a un plus court chemin élémentaire de longueur au plus $n-1$.
\end{frame}


\begin{frame}\frametitle{Exemple : Ford-Bellman}
\centering

\includegraphics[height=5cm]{dj.pdf}
${\small \begin{array}{c|cccccccc} k & s & a & b & c & d & e & f & t
\\ 
\hline 0 &0 &\infty & \infty & \infty & \infty & \infty & \infty & \infty  \\ 
\visible<2-6>{1& \infty & 3 & \infty & \infty & 3 & \infty &  5 & \infty \\}
\visible<3-6>{2 & \infty & \infty & 5 & \infty & 8 & 7 & \infty & \infty \\}
\visible<4-6>{3 & \infty& \infty  & 9 & 5 & 8 & \infty & \infty & 9 \\}
\visible<5-6>{4 &
\infty & \infty & 9 & 6 & \infty & 8 & \infty & 9 \\}
\visible<6>{5 &\infty & \infty & 9 & 10 & 9 & 10 & \infty & 11}
\end{array}}$
\end{frame}







\begin{frame}\frametitle{L'algorithme de Ford-Bellman}


Peut être facilement adapté pour calculer le chemin lui-même (et pas seulement le coût minimum)
 
 \bigskip

 \pause
  \bigskip
Pas de généralisation triviale aux graphes non-orientés (la réduction crée des cycles négatifs)

 \pause
  \bigskip

Converge en $O(mn)$ avec\\
$n$: nombre de sommets\\
$m$: nombres d'arcs


\end{frame}

\subsection{Graphes acycliques : ordre topologique}
\begin{frame}\frametitle{L'idée de Bellman}

Principe d'optimalité de Bellman\\
\pause
La sous-trajectoire d'une trajectoire optimale est encore optimale:

 \begin{proposition}[5.4]
  Soit $G$ un graphe orienté acylique, $P$ un $o$-$v$ chemin et $Q$ son sous-$o$-$u$ chemin, où $u$ est le sommet avant $v$ dans $P$.\\
  Si $P$ est le plus petit $o$-$v$ chemin,\quad
  alors $Q$ est le plus petit $o$-$u$ chemin.
 \end{proposition}
 \vfill
 \pause
 L'équation de Bellman devient 
$f(v)=\min_{u \in N^-(v)} f(u)+c(u,v)$
\vfill
\pause
Calculer tous les $f(v)$ par récurrence :\\

C'est possible selon un ordre dit topologique $\preceq$
tel que $(u,v) \in A \Rightarrow u\preceq v$
\end{frame}




\begin{frame}\frametitle{Programmation dynamique}

{\footnotesize
 On a
\begin{enumerate}
\item système dynamique à temps discret $x_{k+1}=f_k(x_k,u_k),\quad k=1,2,\ldots,N$
\item fonction de coût additive dans le temps.
\end{enumerate}

\bigskip

$x_0$ : {\blue état initial}.

\bigskip

$x_k$ : {\blue état} au début de la {\blue période $k$}. 

\bigskip

$u_k$ : {\blue décision} pour la période $k$.

\bigskip

$c_k(x_k,x_{k+1})$ : coût de la {\blue transition} de $x_k$ à $x_{k+1}$ sur la période $k$.

\bigskip\bigskip

Trouver la {\blue trajectoire} $x_0,x_1,\ldots,x_N$ de coût total $\sum_{k=1}^Nc_k(x_k,x_{k+1})$ minimal : 

peut se résoudre par la {\blue programmation dynamique}.}


\end{frame}

\begin{frame}\frametitle{Programmation dynamique}
$V(k,x):=$ coût minimal de la trajectoire amenant le système dans l'état $x$ en $k$ étapes.

\bigskip
\bigskip

Programmation dynamique : équation de Bellman pour tout $y$

$$V(k,y)=\min_{x\in X_{k-1}}(V(k-1,x)+c_{k-1}(x,y))$$

\bigskip
\bigskip

Algorithme : calculer de proche en proche

\end{frame}


\begin{frame}\frametitle{Gestion de stock}
Dynamique d'un stock : $x_{k+1}=x_k-d_k+u_k$, 

\bigskip

$d_k$ : demande pour la période $k$ (supposée connue) 

$x_k\in\mathbb{Z}$ : nombre d'unités disponibles en début de période $k$ 

$u_k$ : nombre d'unités commandées (et reçues immédiatement) en début de période $k$ 

$K$ : capacité maximale de stockage

$c(u_k)+g(x_{k+1})$ : coût de gestion de stock pour la période $k$ en
\begin{itemize}
\item $c(u_k)$ coût de réapprovisionnement
\item  $g(x_{k+1})$ coût de stockage ou coût de pénurie 
\end{itemize}

\bigskip

{\red Objectif.} Minimiser $\sum_{k=0}^{N-1}c(u_k)+g(x_{k+1}).$ 

\end{frame}

\begin{frame}\frametitle{Gestion de stock}
Modélisation par la programmation dynamique

\bigskip

{\red périodes} : périodes $k=1,\ldots, N$

\bigskip

{\red états} : valeurs possibles $x_k$ de niveau de stock, 

\bigskip

{\red transitions} : $x_k\rightarrow x_{k+1}$ tq $x_{k+1}$ satisfasse simultanément $x_{k+1}\in\mathbb{Z}$, $x_{k+1}+d_k\leq K$ et $x_{k+1}\geq x_k-d_k$ 

\bigskip


{\red coût de la transition} : $x_k\rightarrow x_{k+1}$ est $c(x_{k+1}-x_k+d_k)+g(x_{k+1})$

\bigskip
\bigskip

{\red Objectif.} Minimiser $\sum_{k=0}^{N-1}c(x_{k+1}-x_k+d_k)+g(x_{k+1})$  (critère additif = somme des coûts des transitions de la trajectoire).

\end{frame}


\begin{frame}\frametitle{Programmation dynamique $=$ plus court chemin}
Programmation dynamique = plus court chemin dans un graphe acircuitique

\bigskip
\bigskip

\begin{center}
\begin{tabular}{c|c}Prog. dyn. & Plus court $s$-$t$ chemin\\
\hline
états $\times$ périodes & sommets \\
transitions & arcs \\
coût de la transition & longueur l'arc \\
trajectoire & chemin \\
trajectoire optimale & plus court chemin
\end{tabular}
\end{center}

Si plusieurs états de départ ou plusieurs états à l'arrivée, on peut ajouter des sommets fictifs $s$ et $t$, et des transitions de coût $=0$.

\end{frame}

\begin{frame}\frametitle{Programmation dynamique $=$ plus court chemin}
\includegraphics[width=10cm]{illustrdyn.pdf}
\end{frame}

\begin{frame}\frametitle{Programmation dynamique $=$ plus court chemin}
\includegraphics[width=10cm]{illustrdyn_opt.pdf}
\end{frame}

\begin{frame}\frametitle{Programmation dynamique $=$ plus court chemin}
\includegraphics[width=10cm]{illustrdyn_opt_truc.pdf}
\end{frame}



\section{Complexité résumé}
\begin{frame}\frametitle{Complexité : Résumé}
\centering
{\small \begin{tabular}{c|c}

& Complexité \\
\hline
Graphe orienté,& $O(m+nlog(n))$  \\
 $c(a)\geq 0$  & (Dijkstra)\\
\hline
Graphe orienté,   & $O(m)$  \\ 
acyclique & (Programmation
dynamique)\\

\hline
Graphe orienté  & $O(nm)$  \\  
sans cycle & (Programmation
dynamique, \\

 absorbant &   Ford-Bellman) \\
\hline
Graphe orienté  & {\bf NP}-difficile \\
 & \\
\hline\hline
Graphe non-orienté,  & $O(m+nlog(n))$ \\ 
$c(a)\geq 0$ & (Dijkstra) \\
\hline
Graphe non-orienté,   & $O(n^3)$ \\ sans cycle absorbant & (plus compliqué)\\

\hline Graphe non-orienté & {\bf NP}-difficile \\
  &
\end{tabular}}
\end{frame}


\end{document}